# 设计模式案例实现

## [参考文档](https://github.com/youngyangyang04/kama-DesignPattern)

[01.单例模式（饿汉）](./create/01-singleton-hunger.ts)
[01.单例模式（懒汉）](./create/01-singleton-lazy.ts)

## 创建型模式

- 单例模式（Singleton）： 分为饿汉模式和懒汉模式，饿汉先
- 简单工厂模式(不属于 23 钟设计模式)：通过 if、else 判断，简化了客户端。但是如果要添加新产品，需要修改工厂类代码。
- 工厂方法模式（factory Method）：在简单工厂模式技术上添加抽象工厂和具体工厂，每个具体工厂创建一个具体产品，添加新的产品需要添加新的工厂，而不修改原来的代码。
- 抽象工厂模式（Abstract Factory）
  - 在工厂方法模式基础上，每个工厂可以生产一系列相关的产品。
- 建造者模式：（Builder）
- 原型模式：Prototype）

## 结构型

- 适配器模式（Adapter）
- 桥接模式（Bridge）: 适合笛卡尔积的组合
- 组合模式（Composite）: 组合模式适用于任何需要构建具有部分-整体层次结构的场景，比如组织架构管理、文件系统的文件和文件夹组织等。
- 装饰者模式（Decorator）
- 外观模式（Facade）
- 享元模式（Flyweight）
- 代理模式（Proxy）

## 行为型

- 观察者模式（Observer）
- 策略模式（Strategy）
- 命令模式（Command）
- 中介者模式（Mediator）
- 备忘录模式 （Memento）
- 模板方法模式（Template Method）
- 迭代器模式（Iterator）
- 责任链模式（Chain of Responsibility）
- 解释器模式（Interpreter）
- 访问者模式（Visitor）

## 区别

- 简单工厂、工厂方法、抽象工厂的区别
  - 简单工厂模式：一个工厂方法创建所有具体产品
  - 工厂方法模式：一个工厂方法创建一个具体产品
  - 抽象工厂模式：一个工厂方法可以创建一类具体产品

- 抽象工厂模式 与 建造者模式的区别
  - 抽象工厂模式：适合创建一系列相关的对象，封装了对象创建的逻辑，便于扩展和管理不同的产品族。
  - 建造者模式：适合构建复杂对象，支持一步一步的构建过程，能灵活地处理不同的配置选项。

- 适配器模式和代理模式的区别
  - 适配器模式主要是让不能访问的能访问
  - 代理模式主要是限制访问，或在访问之前或之后做一些其他的事

## 注意点

- [装饰器模式](./structural/04.decorator.ts)的抽象类的使用
- [x] [桥接模式](./structural/03.bridge.ts) : 有点难理解，感觉还是太散了，需要在客户端组合。目的是什么？就是方便组装？使用场景呢？
  - 代码中的桥接就是两个抽象接口其中一个抽象接口接入到另一个抽象接口中，二者都有对应的实现类，这样就可以编程笛卡尔积组合，进而增强实用性和扩展性。
  - 如果程序设计上出现笛卡尔积的情况时就要考虑采用该设计模式了。如：热的小杯奶茶、热的大杯奶茶、凉的小杯奶茶、凉的大杯奶茶。
- [ ] [享元模式](./structural/07.flyWeight.ts) 案例不好，理解的不行，需要一个更好的案例。案例 （围棋 内部状态 颜色、外部状态 坐标）。

## 实战点

- [ ] [享源模式， studio 的 block 拖动实力化问题](./structural/07.flyWeight.ts)
